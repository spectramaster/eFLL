# eFLL 集成指南

本指南总结了在嵌入式项目中集成 eFLL 时需要关注的关键配置点，帮助团队在资源受限、实时性要求严格的环境下稳定运行模糊控制器。

## 内存配置

- **静态与动态分配**：eFLL 的对象（`Fuzzy`, `FuzzyInput`, `FuzzyOutput`, `FuzzySet` 等）可以在静态区或者全局区预先实例化，避免在中断或实时循环中使用 `new`/`delete` 带来的碎片化。若必须使用动态分配，建议统一在系统初始化阶段完成并在 RAM 监控工具中验证堆峰值。
- **对象复用**：针对多通道控制任务，可通过共享 `Fuzzy` 实例并在每次执行前重新设置输入值的方式复用对象。请务必调用 `Fuzzy::reset()`（若使用自定义扩展）或在调用 `setInput()` 前手动清除历史输入，避免上一周期的残留数据影响当前周期。
- **查表与常量区**：将隶属度参数、规则表等常量移动至只读存储器（如 `const` 数组、`PROGMEM` 或 STM32 的 Flash）可以进一步节省 RAM。对于 STM32，推荐使用 `constexpr` 数据结构并在链接脚本中确认常量被映射至 Flash。

## 定点模式

- **精度选择**：在没有硬件 FPU 的 MCU（如大多数 STM32F1/F0）上，可通过编译器宏启用定点实现。例如将输入/输出缩放到整数区间 `[0, 1000]` 并以整型存储，调用 `setInput()` 与 `defuzzify()` 前后执行统一的缩放转换。
- **避免溢出**：在实现定点模式时，务必留意加法、乘法、最小/最大操作的临时变量范围。建议采用 32 位整型保存中间值，并在编写隶属度函数时加入饱和逻辑。
- **一致性验证**：同一项目中使用浮点和定点实现时，可在桌面端构建一个对比测试，将浮点结果作为基准，逐条比较 defuzzification 输出差异，确认误差处于允许范围内。

## 线程安全

- **单线程假设**：eFLL 核心对象没有内部锁机制，默认在单线程或单中断上下文中运行。若在 RTOS 环境（如 FreeRTOS）中跨任务共享 `Fuzzy` 实例，需要使用互斥量或消息队列保护 `setInput()`、`fuzzify()` 与 `defuzzify()` 的调用顺序。
- **中断上下文**：在中断服务程序中调用 eFLL 时，避免与主循环共享同一实例；如必须共享，请确保在进入中断前禁用相关任务或使用双缓冲模式复制输入输出。
- **内存可见性**：多核或带缓存的处理器上，记得在写入输入值后使用内存屏障或 RTOS 的同步 API，以确保线程间的可见性。

## 时序设计

- **采样周期**：根据被控对象的动态特性选择合适的采样周期 `Ts`。通常建议 `Ts` 为被控系统时间常数的 1/5 至 1/10，以便模糊控制器有足够的响应频率。
- **执行预算**：测量 `fuzzify()` 与 `defuzzify()` 的执行时间，保证其总和加上输入采集与输出执行的时间小于采样周期。对 STM32 可结合 `DWT` 计数器或 `HAL_GetTick()` 进行 profiling。
- **调度方式**：对于裸机系统，可在主循环中使用固定节拍定时器触发 eFLL 计算；在 RTOS 中，使用周期性任务或软定时器触发模糊控制逻辑，并在任务内保持优先级高于其他非实时任务。
- **输出滤波**：在实际执行前对 defuzzify 输出进行限幅或滑动平均，减少噪声对执行器的冲击。务必确认滤波延迟不会破坏闭环稳定性。

## 集成步骤速览

1. 明确输入输出变量及其隶属度函数，并在代码中定义 `FuzzySet` 对象。
2. 构建 `FuzzyRuleAntecedent` 与 `FuzzyRuleConsequent`，将规则注册到 `Fuzzy` 实例。
3. 在系统初始化阶段完成对象实例化、参数表加载和定点缩放配置。
4. 在周期性任务中：采集传感器 → 归一化/缩放 → 调用 `setInput()` → `fuzzify()` → `defuzzify()` → 输出执行器命令。
5. 结合本仓库 `docs/temperature_control_case.md` 中的案例，验证输入输出映射与调试流程。

## 参考资料

- [README.md](../README.md) 中的快速开始章节
- `examples/` 目录中的平台示例
- `tests/` 目录中的单元测试，帮助验证自定义扩展的正确性
